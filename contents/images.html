<!DOCTYPE html> <!-- HTML5文書であることを宣言 -->
<html lang="ja"> <!-- ドキュメントの言語を日本語に指定 -->
<head>
    <meta charset="UTF-8"> <!-- 文字エンコーディングをUTF-8に設定（文字化け防止） -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <!-- スマートフォン等での表示設定。幅をデバイス幅に、初期ズーム倍率を1.0、ユーザーによるズームを禁止 -->
    <title>画像の雨</title> <!-- ブラウザのタブに表示されるタイトル -->
    <meta name="article-number" content="000006">
    <meta name="description" content="多種多様な画像を雨のように降らせます。">

    <!-- Google Fontsの読み込み -->
    <!-- Webフォントを利用するためにGoogle Fontsサーバーに接続 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- 必要なフォントファミリーと太さを指定して読み込み -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@400;700&family=Yuji+Syuku&family=Mochiy+Pop+One&display=swap" rel="stylesheet">

    <style>
        /* --- グローバルCSS変数定義 --- */
        /* :root セレクタはHTML文書のルート要素 (<html>) を対象とし、
           ここで定義されたCSSカスタムプロパティ（変数）は文書全体で使用可能 */
        :root {
            /* 色設定 (これらの値はテーマクラスによって上書きされる可能性がある) */
            --background-color: #f0f0f0;       /* ページの基本背景色 */
            --text-color: #333;             /* ページの基本文字色 */
            --accent-color: #007bff;        /* 強調色 (フォーカス時などに使用) */
            --panel-bg-color: rgba(255, 255, 255, 0.9); /* 設定パネルの背景色 (半透明) */
            --panel-text-color: #333;       /* 設定パネルの文字色 */
            --button-bg-color: #007bff;      /* ボタンの背景色 */
            --button-text-color: #fff;        /* ボタンの文字色 */

            /* フォント設定 (これもテーマや特定のクラスで上書きされる可能性がある) */
            --current-font-family: 'Noto Sans JP', sans-serif; /* 現在適用されているフォント */

            /* アニメーション設定 */
            --base-fall-duration: 12s;       /* 画像が画面上端から下端まで落ちるのにかかる基本時間 (秒) */

            /* メーターの色設定 */
            --meter-bg-color: #e9ecef;       /* メーターの背景バーの色 */
            --meter-fill-color: #007bff;     /* メーターの充填部分の色 */
        }

        /* --- bodyと基本レイアウト --- */
        /* body要素はWebページ全体の表示領域を指す */
        body {
            margin: 0; /* ブラウザがデフォルトで設定する外側の余白を削除 */
            padding: 0; /* ブラウザがデフォルトで設定する内側の余白を削除 */
            font-family: var(--current-font-family); /* CSS変数を使ってフォントを適用 */
            background-color: var(--background-color); /* CSS変数を使って背景色を適用 */
            color: var(--text-color); /* CSS変数を使って文字色を適用 */
            overflow: hidden; /* ページ内容が画面サイズを超えてもスクロールバーを表示しない */
            width: 100vw;     /* 画面の表示領域の幅全体を使用 (viewport width) */
            height: 100vh;    /* 画面の表示領域の高さ全体を使用 (viewport height) */
            /* transition: テーマ変更時に背景色や文字色が滑らかに変化するようにアニメーションを設定 */
            transition: background-color 0.5s, color 0.5s;
        }

        /* --- 画像が降るコンテナ --- */
        /* id="image-container" が指定された要素のスタイル */
        #image-container {
            position: relative; /* 子要素 (.image-item) を絶対位置指定 (position: absolute) する際の基準点となる */
            width: 100%;       /* 親要素 (body) の幅いっぱいに広がる */
            height: 100%;      /* 親要素 (body) の高さいっぱいに広がる */
            overflow: hidden;  /* このコンテナからはみ出した子要素 (画像) は表示しない */
        }

        /* --- 降ってくる画像のコンテナスタイル --- */
        /* class="image-item" が指定された要素 (画像一枚一枚を囲むdiv) のスタイル */
        .image-item {
            position: absolute; /* 親要素 (#image-container) を基準とした絶対位置に配置 */
            opacity: 0;         /* 初期状態では透明。アニメーションで徐々に表示される */
            /* アニメーション関連のプロパティ */
            animation-name: fall; /* 適用するアニメーションの名前 (@keyframes fall で定義) */
            animation-timing-function: linear; /* アニメーションの進行速度 (一定) */
            animation-iteration-count: 1;      /* アニメーションの繰り返し回数 (1回のみ) */
            animation-fill-mode: forwards;   /* アニメーション終了後、最後のキーフレームの状態を維持する */
            /* will-change: アニメーション中に変化するプロパティをブラウザに伝え、描画パフォーマンスの最適化を期待する */
            will-change: transform, opacity;
            animation-duration: var(--base-fall-duration); /* アニメーションの時間をCSS変数で指定 */

            /* 落下時の回転角度をJavaScriptから動的に設定するためのCSS変数 */
            --initial-rotate: -5deg; /* アニメーション開始時の初期角度（デフォルト値） */
            --final-rotate: 10deg;   /* アニメーション終了時の最終角度（デフォルト値） */

            /* 画像の外観に関するスタイル */
            padding: 5px; /* 画像の周りに5pxの余白を作成 */
            background-color: rgba(255, 255, 255, 0.5); /* 背景を半透明の白にして画像を見やすくする */
            border-radius: 8px; /* 角を8pxの半径で丸める */
            box-shadow: 0 4px 8px rgba(0,0,0,0.15); /* 要素に影をつけて立体感を出す */
            /* visibility: hidden; はアニメーション開始が見えなくなるため、ここでは使用しない */
        }

        /* --- 画像自体のスタイル --- */
        /* class="image-item" の中にある img 要素のスタイル */
        .image-item img {
            display: block; /* img要素が持つ下部の余白を取り除く */
            width: 100%;   /* 親要素 (.image-item) の幅いっぱいに表示 */
            height: auto;  /* 画像の縦横比を維持したまま高さを自動調整 */
            border-radius: 5px; /* 画像自体の角も少し丸める */
            /* object-fit: cover; 画像が指定された幅/高さに合わない場合、アスペクト比を保ちつつ要素全体を覆うように調整（一部が切り取られる可能性あり） */
            object-fit: cover;
        }

        /* --- 落下アニメーション (@keyframes) --- */
        /* "fall" という名前のアニメーションのキーフレーム（変化点）を定義 */
        @keyframes fall {
            /* アニメーション開始時点 (0%) */
            0% {
                /* Y軸方向に-150px移動（画面外上部から開始）、指定された初期角度で回転 */
                transform: translateY(-150px) rotate(var(--initial-rotate));
                opacity: 0; /* 透明な状態 */
            }
            /* アニメーション全体の10%経過時点 */
            10% {
                opacity: 1; /* 不透明になる */
                /* Y軸方向の移動をリセットし、回転も0度にする */
                transform: translateY(0vh) rotate(0deg);
            }
            /* アニメーション全体の90%経過時点 */
            90% {
                opacity: 1; /* 不透明な状態を維持 */
            }
            /* アニメーション終了時点 (100%) */
            100% {
                /* Y軸方向に画面の高さ(100vh) + 5vh 分移動（画面外下部へ）、指定された最終角度で回転 */
                transform: translateY(105vh) rotate(var(--final-rotate));
                opacity: 0; /* 再び透明になる */
            }
        }

        /* --- テーマ別スタイル定義 --- */
        /* body要素に特定のテーマクラスが付与された場合のスタイル上書き */

        /* ダークテーマ */
        body.theme-dark {
            /* CSS変数の値をダークテーマ用に上書き */
            --background-color: #222; --text-color: #f0f0f0;
            --panel-bg-color: rgba(50, 50, 50, 0.9); --panel-text-color: #f0f0f0;
            --button-bg-color: #0056b3; --meter-bg-color: #444; --meter-fill-color: #0056b3;
        }
        /* ダークテーマ時の画像アイテムの背景色も調整 */
        .theme-dark .image-item { background-color: rgba(80, 80, 80, 0.5); }

        /* 空テーマ */
        body.theme-sky {
            /* 背景色にグラデーションを指定 */
            --background-color: linear-gradient(to bottom, #87CEEB, #E0F2F7); --text-color: #1A237E;
            --panel-bg-color: rgba(224, 242, 247, 0.9);
            --panel-text-color: #1A237E; --button-bg-color: #1E88E5;
            --meter-bg-color: #cce7ff; --meter-fill-color: #1E88E5;
        }
        /* body.theme-sky の場合、背景にグラデーションを適用 */
        body.theme-sky { background: var(--background-color); }

        /* 桜テーマ */
        body.theme-sakura {
            /* 背景色にグラデーションを指定 */
            --background-color: linear-gradient(to bottom, #FFC0CB, #FFF0F5); --text-color: #C71585;
            --panel-bg-color: rgba(255, 240, 245, 0.9);
            --panel-text-color: #C71585; --button-bg-color: #FF69B4;
            --meter-bg-color: #ffe4e1; --meter-fill-color: #FF69B4;
        }
        /* body.theme-sakura の場合、背景にグラデーションを適用 */
        body.theme-sakura { background: var(--background-color); }

        /* --- フォント切り替え用クラス定義 --- */
        /* これらのクラスをbody要素に追加することで、全体のフォントが切り替わる */
        /* 設定パネルなど、一部のテキスト要素に影響 */
        .font-noto-sans-jp { --current-font-family: 'Noto Sans JP', sans-serif; } /* ゴシック体 */
        .font-noto-serif-jp { --current-font-family: 'Noto Serif JP', serif; } /* 明朝体 */
        .font-yuji-syuku { --current-font-family: 'Yuji Syuku', cursive; } /* 手書き風 */
        .font-mochiy-pop-one { --current-font-family: 'Mochiy Pop One', sans-serif; } /* ポップ体 */

        /* --- 設定ボタンのスタイル --- */
        /* id="settings-button" が指定された要素のスタイル */
        #settings-button {
            position: fixed; /* 画面スクロールに関わらず常に同じ位置に表示 */
            bottom: 20px;    /* 画面下端から20pxの位置 */
            right: 20px;     /* 画面右端から20pxの位置 */
            padding: 12px 18px; /* ボタン内部の余白 */
            font-size: 16px; /* 文字サイズ */
            background-color: var(--button-bg-color); /* 背景色 (テーマ依存) */
            color: var(--button-text-color);     /* 文字色 (テーマ依存) */
            border: none; /* 境界線なし */
            border-radius: 25px; /* 角を丸めて円形に近づける */
            cursor: pointer; /* マウスカーソルを合わせたときに指マークにする */
            box-shadow: 0 4px 8px rgba(0,0,0,0.2); /* 影をつけて立体感を出す */
            z-index: 1001; /* 要素の重なり順序。数値が大きいほど手前に表示 (設定パネルより手前) */
            /* transition: ボタンの背景色や透明度が変化する際に0.3秒かけて滑らかに変化 */
            transition: background-color 0.3s, opacity 0.3s;
        }
        /* マウスカーソルがボタンの上に乗ったときのスタイル */
        #settings-button:hover {
            opacity: 0.85; /* 少し透明度を下げる（色が濃く見える効果） */
        }

        /* --- 設定パネルのスタイル --- */
        /* id="settings-panel" が指定された要素のスタイル */
        #settings-panel {
            position: fixed; /* 画面スクロールに関わらず常に同じ位置に表示 */
            bottom: -100%;   /* 初期状態では画面下端よりさらに下に配置し、隠しておく */
            left: 0;         /* 画面左端に配置 */
            width: 100%;     /* 画面幅いっぱいに広がる */
            background-color: var(--panel-bg-color); /* 背景色 (テーマ依存、半透明) */
            color: var(--panel-text-color);     /* 文字色 (テーマ依存) */
            box-shadow: 0 -4px 10px rgba(0,0,0,0.1); /* パネル上部に影をつけて境界を明確にする */
            padding: 20px;   /* パネル内部の余白 */
            box-sizing: border-box; /* paddingとborderを要素の幅・高さに含めるようにする */
            z-index: 1000;   /* 要素の重なり順序 (設定ボタンよりは奥) */
            border-top-left-radius: 20px;  /* 左上の角を丸める */
            border-top-right-radius: 20px; /* 右上の角を丸める */
            max-height: 80vh; /* パネルの最大の高さを画面の高さの80%までに制限 */
            overflow-y: auto; /* 内容がパネルの高さを超えた場合に縦スクロールバーを表示 */

            /* 初期状態では非表示で操作不可 */
            visibility: hidden; /* 要素を完全に非表示（スペースも空けない） */
            opacity: 0;         /* 透明 */
            /* transition: パネルが表示/非表示される際のプロパティ変化を滑らかにアニメーション */
            transition: bottom 0.5s ease-in-out, opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
        }
        /* class="open" が付与されたときの #settings-panel のスタイル */
        #settings-panel.open {
            bottom: 0;    /* 画面下端にぴったりくっつくように表示 */
            opacity: 1;     /* 不透明にする */
            visibility: visible; /* 表示状態にする */
        }

        /* --- 設定パネル内の各設定グループ --- */
        /* class="setting-group" が指定された要素 (各設定項目を囲むdiv) のスタイル */
        .setting-group {
            margin-bottom: 15px; /* 各設定グループの下に15pxの余白を設ける */
        }
        /* 設定グループ内のラベル (label要素) のスタイル */
        .setting-group label {
            display: block; /* ラベルをブロック要素として扱い、改行させる */
            margin-bottom: 8px; /* ラベルの下に8pxの余白 */
            font-weight: bold; /* 文字を太字にする */
            font-size: 1em;   /* 親要素と同じ文字サイズ */
        }
        /* 設定グループ内のセレクトボックス (select) とレンジスライダー (input[type="range"]) の共通スタイル */
        .setting-group select,
        .setting-group input[type="range"] {
            width: 100%; /* 親要素の幅いっぱいに広げる */
            padding: 10px; /* 内側の余白 */
            border-radius: 8px; /* 角を丸める */
            border: 1px solid #ccc; /* 境界線 */
            background-color: var(--background-color); /* 背景色 (テーマ依存) */
            color: var(--text-color);             /* 文字色 (テーマ依存) */
            font-size: 1em; /* 文字サイズ */
            box-sizing: border-box; /* paddingとborderを幅に含める */
            /* transition: フォーカス時のスタイル変化を滑らかにする */
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        /* レンジスライダーのデフォルトのpaddingをリセット */
        .setting-group input[type="range"] {
            padding: 0;
        }
        /* セレクトボックスやレンジスライダーがフォーカスされた（クリックまたはTabで選択された）ときのスタイル */
        .setting-group select:focus,
        .setting-group input[type="range"]:focus {
            outline: none; /* ブラウザデフォルトのフォーカス時の枠線（アウトライン）を消す */
            border-color: var(--accent-color); /* 境界線の色をアクセントカラーにする */
            /* アクセントカラーで影をつけてフォーカス状態を明確にする */
            box-shadow: 0 0 0 2px var(--accent-color-alpha, rgba(0, 123, 255, 0.25));
        }
        /* スライダーの現在の値を表示するspan要素 (class="value-display") のスタイル */
        .value-display {
            display: inline-block; /* インライン要素のように配置しつつ、幅や高さを持てるようにする */
            margin-left: 10px; /* 左側に10pxの余白 */
            font-weight: bold; /* 太字 */
        }
        /* レンジスライダーの左右にあるラベル (例: "遅い", "速い") を含むdiv (class="range-labels") 内のspan要素のスタイル */
        .range-labels span {
            font-size: 0.9em; /* 少し小さい文字サイズ */
            color: var(--text-color); /* 文字色 (テーマ依存) */
        }
        /* 左右ラベルのうち、最後のspan要素 (右側のラベル) のスタイル */
        .range-labels span:last-child {
            float: right; /* 右側に寄せる */
        }

        /* --- 画像URLストックメーターのスタイル --- */
        /* id="image-stock-meter-container" が指定された要素のスタイル */
        #image-stock-meter-container {
            margin-top: 20px; /* 上の要素との間に20pxの余白 */
            padding-top: 15px; /* 内側上部に15pxの余白 */
            /* 上の要素との境界線。色をパネルの文字色に合わせる */
            border-top: 1px solid var(--panel-text-color);
            opacity: 0.8; /* 少し透明にする */
        }
        /* メーターのラベル (p要素) のスタイル */
        #image-stock-meter-container p {
            margin: 0 0 5px 0; /* 上右左のmarginは0、下に5pxのmargin */
            font-size: 0.9em; /* 少し小さい文字サイズ */
        }
        /* メーターの背景バー (class="meter-bar") のスタイル */
        .meter-bar {
            width: 100%; /* 幅いっぱい */
            height: 20px; /* 高さ20px */
            background-color: var(--meter-bg-color); /* 背景色 (テーマ依存) */
            border-radius: 10px; /* 角を丸める */
            overflow: hidden; /* 中の充填部分 (.meter-fill) がはみ出さないようにする */
            border: 1px solid rgba(0,0,0,0.1); /* 薄いグレーの境界線 */
        }
        /* メーターの充填部分 (class="meter-fill") のスタイル */
        .meter-fill {
            width: 0%; /* 初期状態の幅は0%。JavaScriptで動的に変更される */
            height: 100%; /* 高さを背景バーに合わせる */
            background-color: var(--meter-fill-color); /* 充填色 (テーマ依存、JavaScriptで量によって変化する場合あり) */
            border-radius: 10px 0 0 10px; /* 左側の角だけ丸める (右側は親のoverflow:hiddenで隠れる) */
            /* transition: 幅や背景色が変化する際に滑らかにアニメーション */
            transition: width 0.2s ease-out, background-color 0.3s;
            /* メーターバー内に表示するテキストのスタイル */
            text-align: center; /* 文字を中央揃え */
            line-height: 20px; /* 行の高さをバーの高さに合わせ、垂直方向中央揃え */
            color: var(--button-text-color); /* 文字色 (ボタン文字色と同じ) */
            font-size: 0.8em; /* 小さい文字サイズ */
            font-weight: bold; /* 太字 */
        }
        /* ================================================================== */
        /* ナビゲーションメニューのスタイル (ここからコピー)                   */
        /* ================================================================== */

        /* メニューを開閉するアイコンボタンのスタイル */
        #menu-toggle-icon {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            position: fixed;
            /* 画面に固定表示 */
            top: 15px;
            /* 画面上から15pxの位置 */
            right: 20px;
            /* 画面右から20pxの位置 */
            font-size: 28px;
            /* アイコンの文字サイズ */
            font-weight: bold;
            /* 太字にする */
            color: #333;
            /* アイコンの色 (濃いグレー) */
            background-color: rgba(255, 255, 255, 0.8);
            /* 背景色 (半透明の白) */
            width: 45px;
            /* ボタンの幅 */
            height: 45px;
            /* ボタンの高さ */
            border-radius: 50%;
            /* 円形にする */
            text-align: center;
            /* 文字を中央揃え */
            line-height: 45px;
            /* 文字を垂直方向に中央揃え */
            cursor: pointer;
            /* カーソルを指マークに */
            z-index: 1002;
            /* 他の要素より手前に表示 */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            /* 影をつけて立体感を出す */
            transition: transform 0.2s, background-color 0.2s;
            /* アニメーション効果 */
        }

        /* アイコンにマウスを乗せたときのスタイル */
        #menu-toggle-icon:hover {
            transform: scale(1.1);
            /* 少し大きくする */
            background-color: rgba(255, 255, 255, 1);
            /* 背景を不透明の白に */
        }

        /* フローティングメニュー本体のスタイル */
        #floating-menu {
            position: fixed;
            /* 画面に固定表示 */
            top: 70px;
            /* アイコンの下に配置 */
            right: 20px;
            /* アイコンと同じ右からの位置 */
            background-color: rgba(255, 255, 255, 0.98);
            /* 背景色 (ほぼ不透明の白) */
            padding: 15px 20px;
            /* 内側の余白 */
            border-radius: 8px;
            /* 角を丸くする */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            /* 影をつける */
            display: flex;
            /* 内部のリンクをFlexboxで配置 */
            flex-direction: column;
            /* リンクを縦に並べる */
            gap: 10px;
            /* リンク間の隙間 */
            z-index: 1001;

            /* アニメーションのための初期設定 */
            transform-origin: top right;
            /* 右上を基点にアニメーション */
            transform: scale(0.95);
            opacity: 0;
            visibility: hidden;
            /* 表示されていないときは操作不可に */
            transition: transform 0.2s ease-out, opacity 0.2s ease-out, visibility 0.2s;
        }

        /* メニューが表示されるときのスタイル（showクラスが付与されたとき） */
        #floating-menu.show {
            transform: scale(1);
            opacity: 1;
            visibility: visible;
        }

        /* メニュー内のリンクのスタイル */
        #floating-menu a {
            color: #007bff;
            /* リンクの文字色 */
            text-decoration: none;
            font-size: 1.1rem;
            font-weight: bold;
            padding: 10px;
            transition: background-color 0.2s;
            border-radius: 5px;
        }

        #floating-menu a:hover {
            background-color: #f0f0f0;
            /* ホバー時の背景色 */
        }

        /* ================================================================== */
        /* ナビゲーションメニューのスタイル (ここまでコピー)                   */
        /* ================================================================== */

    </style>
</head>
<body class="theme-sky font-noto-sans-jp"> <!-- 初期テーマとして'sky'、基本フォントとして'noto-sans-jp'を適用 -->
    <!-- ================================================================== -->
    <!-- ナビゲーションメニュー ここから (ここからコピー)                  -->
    <!-- ================================================================== -->
    
    <!-- 画面右上に表示されるメニュー開閉ボタン -->
    <div id="menu-toggle-icon">≡</div>
    
    <!-- クリック時に表示されるフローティングメニュー -->
    <div id="floating-menu">
        <!-- 各ページへのリンク。パスは適宜調整してください -->
        <a href="../index.html">トップページへ</a>
        <a href="../contents.html">コンテンツ一覧へ</a>
    </div>
    
    <!-- ================================================================== -->
    <!-- ナビゲーションメニュー ここまで (ここまでコピー)                  -->
    <!-- ================================================================== -->

    <!-- 画像が実際に表示される領域となるdiv要素 -->
    <div id="image-container"></div>

    <!-- 設定パネルを開閉するためのボタン -->
    <button id="settings-button">設定</button>

    <!-- 設定パネル (初期状態では画面外に隠れている) -->
    <div id="settings-panel">
        <!-- 設定項目グループ: 落下スピード調整 -->
        <div class="setting-group">
            <label for="speed-slider">落下スピード (<span id="speed-value" class="value-display">標準</span>)</label>
            <input type="range" id="speed-slider" min="0.25" max="2.5" step="0.05" value="1.0">
            <div class="range-labels"><span>遅い</span><span>速い</span></div>
        </div>
        <!-- 設定項目グループ: 画像の出現頻度調整 -->
        <div class="setting-group">
            <label for="quantity-slider">画像の出現頻度 (<span id="quantity-value" class="value-display">標準</span>)</label>
            <input type="range" id="quantity-slider" min="0.25" max="3.5" step="0.05" value="1.0">
            <div class="range-labels"><span>少ない</span><span>多い</span></div>
        </div>
        <!-- 設定項目グループ: テーマ選択 -->
        <div class="setting-group">
            <label for="theme-selector">テーマ</label>
            <select id="theme-selector">
                <option value="sky">空と雲</option>
                <option value="light">ライト</option>
                <option value="dark">ダーク</option>
                <option value="sakura">桜</option>
            </select>
        </div>
        <!-- 画像URLストックメーター表示部 -->
        <div id="image-stock-meter-container">
            <p>画像URLストック (<span id="image-stock-count">0</span> / <span id="image-stock-max">0</span>)</p>
            <div class="meter-bar">
                <div id="image-stock-meter-fill" class="meter-fill">0%</div>
            </div>
        </div>
    </div>

    <script>
            /* ================================================================== */
            /* ナビゲーションメニューの制御スクリプト (ここからコピー)             */
            /* ================================================================== */
            document.addEventListener('DOMContentLoaded', () => {
                // HTML要素を取得
                const menuToggleIcon = document.getElementById('menu-toggle-icon');
                const floatingMenu = document.getElementById('floating-menu');

                // アイコンとメニュー要素が存在する場合のみイベントリスナーを設定
                if (menuToggleIcon && floatingMenu) {

                    // メニューアイコンをクリックしたらメニューの表示/非表示を切り替える
                    menuToggleIcon.addEventListener('click', (event) => {
                        // イベントの伝播を停止し、下のdocumentのクリックイベントがすぐに発火するのを防ぐ
                        event.stopPropagation();
                        floatingMenu.classList.toggle('show');
                    });

                    // メニューの外側をクリックしたときにメニューを閉じる
                    document.addEventListener('click', (event) => {
                        // メニューが表示されている状態か確認
                        if (floatingMenu.classList.contains('show')) {
                            // クリックされたのがメニューアイコンでも、メニュー自身でもない場合
                            if (!menuToggleIcon.contains(event.target) && !floatingMenu.contains(event.target)) {
                                floatingMenu.classList.remove('show');
                            }
                        }
                    });
                }
            });
            /* ================================================================== */
            /* ナビゲーションメニューの制御スクリプト (ここまでコピー)             */
            /* ================================================================== */

        /*
         * ==========================================
         * 画像の雨 - JavaScript アプリケーション
         * ==========================================
         * このスクリプトは、画面上にランダムな画像を降らせるアニメーションと、
         * その動作を調整するための設定パネル機能を提供します。
         *
         * 【主な機能】
         * 1. Lorem Picsumからランダムな画像URLを取得・管理
         * 2. 取得した画像を画面上にアニメーション付きで表示（落下）
         * 3. 設定パネルによるカスタマイズ（落下速度、出現頻度、テーマ）
         * 4. 設定内容のローカルストレージへの保存・復元
         * 5. 画像URLのストック状況表示（メーター）
         *
         * 【デバッグについて】
         * もし動作がおかしい場合、まずブラウザの開発者ツール（F12キー等）を開き、
         * 「コンソール」タブにエラーメッセージが表示されていないか確認してください。
         * コード中の `// console.log(...)` の行頭の `//` を削除すると、
         * 処理の実行状況がコンソールに出力され、問題解決の手がかりになります。
         */

        // アプリケーション全体を管理するオブジェクト 'FallingImages'
        const FallingImages = {
            /* --- 設定値 (config) ---
             * アプリケーションの基本的な動作や制限を定義する定数値。
             * ここの値を変更することで、アプリの挙動を調整できます。
             */
            config: {
                // 表示関連の設定
                maxImagesOnScreen: 3000,     // 画面上に同時に表示できる画像の最大数（増やしすぎると重くなる）
                baseSpawnInterval: 500,   // 画像が新しく出現する基本的な時間間隔（ミリ秒単位, 1000ms = 1s）
                baseFallDuration: 12,     // 画像が画面上端から下端まで落下するのにかかる基本的な時間（秒単位）
                minSpawnIntervalSafety: 150, // 実際の画像出現間隔の最小値（ミリ秒）。負荷軽減のため、これより短くならないようにする。

                // 画像ソース (Lorem Picsum) 関連の設定
                imageUrlGenerationInterval: 8000, // 新しい画像URLをまとめて生成する基本的な時間間隔（ミリ秒）
                imageUrlGenerationCount: 30,    // 一度の生成処理で取得を試みる画像URLの数
                maxImageUrlListLength: 500,     // アプリ内部で保持（ストック）しておく画像URLの最大数。これを超えると古いものから補充されるイメージ。
                loremPicsumBaseUrl: 'https://picsum.photos/800/450?random=', // 画像取得元サービスのURL
                minApiFetchIntervalSafety: 4000,  // URL生成間隔の最小値（ミリ秒）。ユーザー設定で高速化しても、これより短くならない。
                maxApiFetchIntervalSafety: 60000, // URL生成間隔の最大値（ミリ秒）。ユーザー設定で低速化しても、これより長くならない。

                // 表示される画像のサイズと回転に関する設定
                imageSizeRange: { min: 60, max: 200 }, // 落下する画像の幅(px)を、この範囲内でランダムに決定
                initialRotationRange: { min: -8, max: 8 }, // アニメーション開始時の画像の回転角度（度）のランダム範囲
                finalRotationRange: { min: -10, max: 10 },   // アニメーション終了時の画像の回転角度（度）のランダム範囲

                // UI（ユーザーインターフェース）関連の設定
                meterUpdateInterval: 200,    // 設定パネル内のストックメーター表示を更新する頻度（ミリ秒）
            },

            /* --- 状態 (state) ---
             * アプリケーションの現在の状況を保持する変数。
             * これらの値はプログラムの実行中に変化します。
             */
            state: {
                imageUrls: [],                     // 現在ストックされている画像URLの配列（リスト）
                spawnIntervalId: null,             // 画像を定期的に出現させるためのタイマーID (setIntervalの戻り値)
                imageUrlGenerationTimeoutId: null, // 画像URLを定期的に生成するためのタイマーID (setTimeoutの戻り値)
                meterUpdateIntervalId: null,       // ストックメーターを定期的に更新するためのタイマーID (setIntervalの戻り値)
                currentSpeedFactor: 1.0,           // 現在の落下スピード係数（ユーザー設定。1.0が標準）
                currentQuantityFactor: 1.0,        // 現在の画像出現頻度係数（ユーザー設定。1.0が標準）
                activeImages: 0,                   // 現在画面に表示されている（落下中の）画像の数
                isPanelOpen: false,                // 設定パネルが開いているかどうか (true: 開いている, false: 閉じている)
                currentTheme: 'sky',               // 現在適用されているテーマ名
                // isInitialized: false            // (オプション) 初期化が完了したかどうかのフラグ
            },

            /* --- 要素 (elements) ---
             * HTMLドキュメント内の特定の要素への参照（DOM要素）を保持するオブジェクト。
             * init() メソッドで実際の要素が取得され、ここに格納されます。
             */
            elements: {
                container: null,            // 画像を表示するメインコンテナ (div#image-container)
                settingsButton: null,       // 設定パネルを開閉するボタン (button#settings-button)
                settingsPanel: null,        // 設定パネル本体 (div#settings-panel)
                speedSlider: null,          // 落下スピード調整スライダー (input#speed-slider)
                speedValueDisplay: null,    // 落下スピードの現在値を表示する要素 (span#speed-value)
                quantitySlider: null,       // 出現頻度調整スライダー (input#quantity-slider)
                quantityValueDisplay: null, // 出現頻度の現在値を表示する要素 (span#quantity-value)
                themeSelector: null,        // テーマ選択ドロップダウン (select#theme-selector)
                imageStockCount: null,      // 画像URLストック数を表示する要素 (span#image-stock-count)
                imageStockMax: null,        // 画像URLストックの最大数を表示する要素 (span#image-stock-max)
                imageStockMeterFill: null,  // ストックメーターの充填バー要素 (div#image-stock-meter-fill)
            },

            /* --- 初期化 (init) ---
             * アプリケーションが開始されるときに最初に呼び出されるメソッド。
             * 必要な要素の取得、イベントリスナーの設定、初期設定の適用などを行います。
             */
            init() {
                // console.log("FallingImages.init() called"); // デバッグ用ログ

                // 1. HTML要素への参照を取得し、elementsオブジェクトに格納
                // document.getElementByIdを使って、HTML内のIDに対応する要素を探す
                this.elements.container = document.getElementById('image-container');
                this.elements.settingsButton = document.getElementById('settings-button');
                this.elements.settingsPanel = document.getElementById('settings-panel');
                this.elements.speedSlider = document.getElementById('speed-slider');
                this.elements.speedValueDisplay = document.getElementById('speed-value');
                this.elements.quantitySlider = document.getElementById('quantity-slider');
                this.elements.quantityValueDisplay = document.getElementById('quantity-value');
                this.elements.themeSelector = document.getElementById('theme-selector');
                this.elements.imageStockCount = document.getElementById('image-stock-count');
                this.elements.imageStockMax = document.getElementById('image-stock-max');
                this.elements.imageStockMeterFill = document.getElementById('image-stock-meter-fill');

                // 2. 必須要素が存在するか確認（堅牢性のため）
                // もし主要な要素が見つからなければ、エラーを出力して処理を中断
                if (!this.elements.container || !this.elements.settingsButton || !this.elements.settingsPanel) {
                    console.error("初期化エラー: 必須のHTML要素が見つかりません。HTMLのIDを確認してください。 (image-container, settings-button, settings-panel)");
                    return; // ここで処理を終了
                }

                // 3. 状態変数の初期化
                this.state.imageUrls = []; // 画像URLプールを空にする

                // 4. イベントリスナー（ユーザー操作への反応）を設定
                this.setupEventListeners();

                // 5. ローカルストレージから前回の設定を読み込み、適用する
                this.applyInitialSettings(); // この中で画像の落下やURL生成も開始される

                // 6. 画像URLストックメーターを初回更新
                this.updateImageUrlStockMeter();

                // this.state.isInitialized = true; // 初期化完了フラグを立てる
                // console.log("FallingImagesの初期化が正常に完了しました。"); // デバッグ用ログ
            },

            /* --- イベントリスナー設定 (setupEventListeners) ---
             * ユーザーの操作（クリック、スライダーの移動など）に対する反応を設定するメソッド。
             * 各HTML要素に対して、特定のイベントが発生したときにどの処理を実行するかを登録します。
             */
            setupEventListeners() {
                // console.log("setupEventListeners called"); // デバッグ用ログ

                // 1. 設定ボタン (settingsButton) がクリックされたときの処理を登録
                this.elements.settingsButton.addEventListener('click', () => {
                    // console.log("設定ボタンがクリックされました"); // デバッグ用ログ
                    // 設定パネルの表示/非表示を切り替えるメソッドを呼び出す
                    this.toggleSettingsPanel();

                    // パネルが開かれた場合のみメーターの更新処理を行う
                    if (this.state.isPanelOpen) {
                        // メーター表示を即時更新
                        this.updateImageUrlStockMeter();
                        // メーターの定期更新タイマーを開始（もし動いていなければ）
                        if (!this.state.meterUpdateIntervalId) {
                            // console.log("メーター更新タイマーを開始します"); // デバッグ用ログ
                            // 指定された間隔 (config.meterUpdateInterval) で updateImageUrlStockMeter を繰り返し実行
                            this.state.meterUpdateIntervalId = setInterval(() => this.updateImageUrlStockMeter(), this.config.meterUpdateInterval);
                        }
                    } else {
                        // パネルが閉じられた場合、メーターの定期更新タイマーを停止（もし動いていれば）
                        if (this.state.meterUpdateIntervalId) {
                            // console.log("メーター更新タイマーを停止します"); // デバッグ用ログ
                            clearInterval(this.state.meterUpdateIntervalId); // タイマー解除
                            this.state.meterUpdateIntervalId = null; // タイマーIDをリセット
                        }
                    }
                });

                // 2. 各種設定コントロールの変更イベントに対する処理を登録
                // スピードスライダーの値が変わったとき (inputイベント: ドラッグ中も発生)
                if (this.elements.speedSlider) { // 要素が存在するか確認してからリスナーを設定
                    this.elements.speedSlider.addEventListener('input', (e) => {
                        // updateSpeedメソッドを呼び出し、スライダーの現在の値を数値に変換して渡す
                        this.updateSpeed(parseFloat(e.target.value));
                    });
                }
                // 出現頻度スライダーの値が変わったとき
                if (this.elements.quantitySlider) {
                    this.elements.quantitySlider.addEventListener('input', (e) => {
                        this.updateQuantity(parseFloat(e.target.value));
                    });
                }
                // テーマ選択ドロップダウンの値が変わったとき (changeイベント: 選択が確定したとき)
                if (this.elements.themeSelector) {
                    this.elements.themeSelector.addEventListener('change', (e) => {
                        this.updateTheme(e.target.value); // 選択されたoptionのvalue値を渡す
                    });
                }
            },

            /* --- 画像URLストックメーター更新 (updateImageUrlStockMeter) ---
             * 設定パネル内の画像URLストックメーターの表示（数値、バーの長さ、色）を
             * 現在の state.imageUrls の状況に合わせて更新するメソッド。
             */
            updateImageUrlStockMeter() {
                // メーター表示に必要な要素が存在しない場合は処理を中断
                if (!this.elements.imageStockCount || !this.elements.imageStockMax || !this.elements.imageStockMeterFill) {
                    // console.warn("メーター要素が見つからないため、更新をスキップします。"); // デバッグ用
                    return;
                }

                const currentCount = this.state.imageUrls.length; // 現在のURL数
                const maxCount = this.config.maxImageUrlListLength; // 最大ストック数
                // ストック率 (%) を計算。最大数が0の場合は0%とする。100%を超えないように制限。
                const percentage = maxCount > 0 ? Math.min(100, Math.round((currentCount / maxCount) * 100)) : 0;

                try { // メーター要素へのアクセスでエラーが発生する可能性に備える
                    // 1. テキスト表示を更新 (例: "150 / 500")
                    this.elements.imageStockCount.textContent = currentCount;
                    this.elements.imageStockMax.textContent = maxCount;
                    // 2. メーターバーの幅とテキストを更新 (例: "30%")
                    this.elements.imageStockMeterFill.style.width = `${percentage}%`;
                    this.elements.imageStockMeterFill.textContent = `${percentage}%`;

                    // 3. ストック量に応じてメーターバーの色を変更 (視覚的フィードバック)
                    if (percentage < 20) { // 20%未満は赤色 (警告)
                        this.elements.imageStockMeterFill.style.backgroundColor = '#dc3545'; // BootstrapのDanger色
                    } else if (percentage < 50) { // 50%未満は黄色 (注意)
                        this.elements.imageStockMeterFill.style.backgroundColor = '#ffc107'; // BootstrapのWarning色
                    } else { // 50%以上はテーマに応じた通常色
                        // 現在適用されているCSS変数 `--meter-fill-color` の値を取得して設定
                        const fillColor = getComputedStyle(document.body).getPropertyValue('--meter-fill-color').trim();
                        this.elements.imageStockMeterFill.style.backgroundColor = fillColor || '#007bff'; // 取得できない場合のデフォルト色
                    }
                } catch (error) {
                    // console.error("メーター要素の更新中にエラーが発生しました:", error); // デバッグ用
                }
            },

            /* --- 初期設定の適用 (applyInitialSettings) ---
             * アプリ起動時に、localStorageに保存されている前回の設定値を読み込み、
             * スライダーの位置やテーマなどを復元し、その後、画像の落下とURL生成を開始するメソッド。
             */
            applyInitialSettings() {
                // console.log("applyInitialSettings called"); // デバッグ用ログ
                try { // 設定の読み込みや適用中にエラーが発生する可能性に備える
                    // 1. スピード設定の読み込みと適用
                    // localStorageから 'fallingImagesSpeed' というキーで値を取得
                    const savedSpeed = localStorage.getItem('fallingImagesSpeed');
                    // 保存された値があればそれを使い、なければデフォルトの1.0を使う
                    const initialSpeed = savedSpeed ? parseFloat(savedSpeed) : 1.0;
                    // スライダーの初期位置を設定
                    if (this.elements.speedSlider) this.elements.speedSlider.value = initialSpeed;
                    // updateSpeedを呼び出して内部状態と表示を更新 (第2引数falseで落下はまだ開始しない)
                    this.updateSpeed(initialSpeed, false);

                    // 2. 出現頻度設定の読み込みと適用 (スピード設定と同様)
                    const savedQuantity = localStorage.getItem('fallingImagesQuantity');
                    const initialQuantity = savedQuantity ? parseFloat(savedQuantity) : 1.0;
                    if (this.elements.quantitySlider) this.elements.quantitySlider.value = initialQuantity;
                    this.updateQuantity(initialQuantity, false);

                    // 3. テーマ設定の読み込みと適用
                    // 保存されたテーマ名を取得、なければデフォルトの'sky'を使う
                    const savedTheme = localStorage.getItem('fallingImagesTheme') || 'sky';
                    // ドロップダウンの初期選択状態を設定
                    if (this.elements.themeSelector) this.elements.themeSelector.value = savedTheme;
                    // updateThemeを呼び出してテーマを即時適用
                    this.updateTheme(savedTheme);

                    // 4. 全ての設定を適用後、メインの動作を開始
                    this.startFalling(); // 画像の落下アニメーションを開始
                    this.restartImageUrlGeneration(100); // 少し待ってから(100ms後)画像URLの生成処理を開始

                } catch (error) {
                    // console.error("初期設定の適用中にエラーが発生しました:", error); // デバッグ用ログ
                    // エラーが発生した場合でも、デフォルト設定で動作開始を試みる（フォールバック）
                    this.updateSpeed(1.0, false);
                    this.updateQuantity(1.0, false);
                    this.updateTheme('sky');
                    this.startFalling();
                    this.restartImageUrlGeneration(100);
                }
            },

            /* --- 画像落下開始 (startFalling) ---
             * 画像を画面に定期的に出現させるタイマー (setInterval) を開始するメソッド。
             * 出現間隔は現在のスピード係数と頻度係数に基づいて計算されます。
             */
            startFalling() {
                // console.log("startFalling called"); // デバッグ用ログ
                // もし既にタイマーが動いていたら、それを停止してクリアする（重複防止）
                if (this.state.spawnIntervalId) clearInterval(this.state.spawnIntervalId);

                // 画像が出現する時間間隔を計算
                const spawnInterval = Math.max( // 安全な最小間隔より短くならないように Math.max を使用
                    this.config.minSpawnIntervalSafety, // 設定された最小間隔
                    // 基本間隔をスピード係数と頻度係数で割る（係数が大きいほど間隔は短くなる）
                    this.config.baseSpawnInterval / (this.state.currentSpeedFactor * this.state.currentQuantityFactor)
                );
                // console.log(`計算された出現間隔: ${spawnInterval}ms`); // デバッグ用ログ

                // 最初に一度だけ spawnImage を呼び出して、すぐに画像を表示試行
                this.spawnImage();
                // 計算された間隔 (spawnInterval) ごとに spawnImage メソッドを繰り返し実行するタイマーを設定
                this.state.spawnIntervalId = setInterval(() => {
                    this.spawnImage(); // 画像を1つ出現させる
                }, spawnInterval);
                // console.log("画像落下タイマーを開始しました。 Interval ID:", this.state.spawnIntervalId); // デバッグ用ログ
            },

            /* --- 画像落下停止 (stopFalling) ---
             * 画像を定期的に出現させるタイマー (setInterval) を停止するメソッド。
             */
            stopFalling() {
                // console.log("stopFalling called"); // デバッグ用ログ
                // タイマーIDが存在すれば (= タイマーが動いていれば)
                if (this.state.spawnIntervalId) {
                    clearInterval(this.state.spawnIntervalId); // タイマーを停止
                    // console.log("画像落下タイマーを停止しました。 Interval ID:", this.state.spawnIntervalId); // デバッグ用ログ
                    this.state.spawnIntervalId = null; // タイマーIDをリセット
                }
            },

            /* --- 画像出現 (spawnImage) ---
             * 実際に画面に新しい画像を1つ出現させ、落下アニメーションを開始するメソッド。
             * URLプールからURLを選び、HTML要素を作成してDOMに追加します。
             */
            spawnImage() {
                // console.log(`画像出現試行。表示中: ${this.state.activeImages}, プール残: ${this.state.imageUrls.length}`); // デバッグ用ログ

                // 1. 出現条件のチェック
                // 画面上の画像数が上限に達している場合は、処理を中断
                if (this.state.activeImages >= this.config.maxImagesOnScreen) {
                    // console.log("出現スキップ: 画面上の画像数が上限です。"); // デバッグ用ログ
                    return;
                }
                // 画像URLのストックがない場合は、処理を中断
                if (this.state.imageUrls.length === 0) {
                    // console.log("出現スキップ: 画像URLプールが空です。"); // デバッグ用ログ
                    // URLが枯渇した場合、補充を促す（ただし、生成処理が既に動いていない場合のみ）
                    if (!this.state.imageUrlGenerationTimeoutId) {
                       // console.log("プール枯渇のため、URL即時生成をリクエストします。"); // デバッグ用ログ
                       this.restartImageUrlGeneration(500); // 0.5秒後にURL生成を試みる
                    }
                    return;
                }

                // 2. 画像URLの選択とプールからの削除
                // プールからランダムなインデックスを選び、その位置のURLを取得し、プールから削除する
                const randomIndex = Math.floor(Math.random() * this.state.imageUrls.length);
                const imageUrl = this.state.imageUrls.splice(randomIndex, 1)[0]; // spliceは削除した要素を配列で返すので[0]で取り出す
                // console.log("この画像を降らせます:", imageUrl); // デバッグ用ログ

                // 3. HTML要素の作成 (div > img)
                // 画像と周辺スタイルをまとめるための <div> 要素を作成
                const imageItemElement = document.createElement('div');
                imageItemElement.classList.add('image-item'); // CSSクラス 'image-item' を適用

                // 実際に画像を表示する <img> 要素を作成
                const imgElement = document.createElement('img');
                imgElement.src = imageUrl;          // img要素のソースに選択したURLを設定
                imgElement.alt = "Falling Image";   // 代替テキスト（画像が表示されない場合などに使われる）
                imgElement.loading = "lazy";        // 画像の遅延読み込みを有効にする（画面表示時に読み込み開始）

                // 画像の読み込みに失敗した場合の処理を登録
                imgElement.onerror = () => {
                    // console.warn("画像の読み込みに失敗しました:", imageUrl); // デバッグ用ログ
                    imageItemElement.remove(); // 失敗した画像要素をDOMから削除
                    // 表示中の画像数を安全に減らす (0未満にならないように)
                    this.state.activeImages = Math.max(0, this.state.activeImages - 1);
                };

                // <img>要素を<div>要素の子として追加
                imageItemElement.appendChild(imgElement);

                // 4. スタイル（回転、サイズ、位置、アニメーション時間）の設定
                // ランダムな初期回転角度と最終回転角度を計算し、CSS変数として設定
                const initialRot = Math.random() * (this.config.initialRotationRange.max - this.config.initialRotationRange.min) + this.config.initialRotationRange.min;
                const finalRot = Math.random() * (this.config.finalRotationRange.max - this.config.finalRotationRange.min) + this.config.finalRotationRange.min;
                imageItemElement.style.setProperty('--initial-rotate', `${initialRot}deg`);
                imageItemElement.style.setProperty('--final-rotate', `${finalRot}deg`);

                // ランダムな画像幅を計算し、スタイルとして設定
                const imageWidth = Math.floor(Math.random() * (this.config.imageSizeRange.max - this.config.imageSizeRange.min + 1)) + this.config.imageSizeRange.min;
                imageItemElement.style.width = `${imageWidth}px`;

                // 5. DOMへの追加と最終位置調整
                // 作成した画像要素 (div) を #image-container に追加 (この時点ではまだ透明で表示されない)
                this.elements.container.appendChild(imageItemElement);

                // 要素をDOMに追加した後で、正確な幅とコンテナの幅を取得
                const itemWidth = imageItemElement.offsetWidth || imageWidth; // offsetWidthが取得できない場合のフォールバック
                const containerWidth = this.elements.container.offsetWidth;

                // 画像が画面左右にはみ出さないように、ランダムなX座標（leftプロパティの値）を計算
                let randomX = 10; // コンテナ幅が取得できない場合のデフォルト値
                 if (containerWidth > 0) { // コンテナ幅が正常に取得できた場合のみ計算
                   // 画像幅+左右マージン(20px)がコンテナ幅を超える場合は左端(10px)に配置
                   // そうでなければ、左右10pxのマージンを確保できる範囲でランダムなX座標を設定
                   randomX = (itemWidth + 20 > containerWidth) ? 10 : Math.max(10, Math.min(Math.random() * (containerWidth - itemWidth - 20), containerWidth - itemWidth - 10));
                 }
                imageItemElement.style.left = `${randomX}px`; // 計算したX座標を適用

                // 落下アニメーションの時間を現在のスピード係数に基づいて計算（最低4秒はかかるように）
                const fallDuration = Math.max(4, this.config.baseFallDuration / this.state.currentSpeedFactor);
                imageItemElement.style.animationDuration = `${fallDuration}s`; // アニメーション時間を適用

                // 6. 状態の更新とアニメーション終了処理の設定
                // 表示中の画像数を1増やす
                this.state.activeImages++;
                // console.log(`表示中の画像数が増加: ${this.state.activeImages}`); // デバッグ用ログ

                // アニメーションが終了したときの処理を登録
                // 'animationend' イベントが発生したら、指定した関数を実行
                imageItemElement.addEventListener('animationend', () => {
                    // console.log("アニメーションが終了しました:", imageUrl); // デバッグ用ログ
                    // 要素がまだDOM上に存在する場合のみ削除（エラーや他の要因で既に削除されている可能性を考慮）
                    if (imageItemElement.parentNode) {
                       imageItemElement.remove(); // 要素をDOMから削除
                    }
                    // 表示中の画像数を安全に減らす
                    this.state.activeImages = Math.max(0, this.state.activeImages - 1);
                    // console.log(`表示中の画像数が減少: ${this.state.activeImages}`); // デバッグ用ログ
                }, { once: true }); // { once: true } オプションで、イベントリスナーが一度だけ実行されるようにする

            },

            /* --- 画像URLの生成と追加 (generateAndAddImageUrls) ---
             * Lorem Picsum サービスのURLを組み立てて、画像URLプール (state.imageUrls) に追加するメソッド。
             * プールの上限を超えないように、必要な数だけ生成します。
             */
            generateAndAddImageUrls() {
                // console.log("generateAndAddImageUrls called"); // デバッグ用ログ
                let addedCount = 0; // 今回追加したURL数をカウントする変数
                const currentPoolSize = this.state.imageUrls.length; // 現在のプールサイズ
                // プールの空き容量を計算
                const availableSpace = this.config.maxImageUrlListLength - currentPoolSize;

                // プールに空きがなければ、処理を中断
                if (availableSpace <= 0) {
                    // console.log("画像URLプールは満杯です。生成をスキップします。"); // デバッグ用ログ
                    return;
                }
                // 一度に生成する数 (config.imageUrlGenerationCount) と空き容量の少ない方を採用
                const countToGenerate = Math.min(this.config.imageUrlGenerationCount, availableSpace);

                // console.log(`${countToGenerate} 個の画像URLを生成します。`); // デバッグ用ログ
                // 指定された数だけループしてURLを生成
                for (let i = 0; i < countToGenerate; i++) {
                    // ランダムな幅と高さを決定 (config.imageSizeRange を使用)
                    const width = Math.floor(Math.random() * (this.config.imageSizeRange.max - this.config.imageSizeRange.min + 1)) + this.config.imageSizeRange.min;
                    // 高さは幅と同じ範囲でランダムに決定（正方形に近い画像が多くなる）
                    const height = Math.floor(Math.random() * (this.config.imageSizeRange.max - this.config.imageSizeRange.min + 1)) + this.config.imageSizeRange.min;
                    // キャッシュを回避するためのランダムなクエリパラメータを生成
                    const cacheBuster = Date.now() + Math.random();
                    // Lorem Picsum のURL形式に従ってURLを組み立てる
                    const imageUrl = `${this.config.loremPicsumBaseUrl}${width}/${height}?random=${cacheBuster}`;

                    // 生成したURLをプールの末尾に追加
                    this.state.imageUrls.push(imageUrl);
                    addedCount++; // 追加カウンターを増やす
                }

                // (念のため) プールが上限を超えていないかチェックし、超えていれば古いものから削除
                const overflow = this.state.imageUrls.length - this.config.maxImageUrlListLength;
                if (overflow > 0) {
                    this.state.imageUrls.splice(0, overflow); // 配列の先頭からoverflow個削除
                    // console.warn(`画像URLプールが溢れました。古いURLを ${overflow} 個削除しました。`); // デバッグ用ログ
                }

                // if (addedCount > 0) console.log(`URLを ${addedCount} 個生成・追加しました。現在のプールサイズ: ${this.state.imageUrls.length}`); // デバッグ用ログ
            },

            /* --- API/URL生成間隔の計算 (calculateApiFetchInterval) ---
             * 現在の落下スピード係数と出現頻度係数に基づいて、
             * 画像URLを生成する次のタイミングまでの時間間隔（ミリ秒）を計算するメソッド。
             * 消費が速い（スピード・頻度が高い）ほど、間隔は短くなります。
             * ※ このアプリでは実際のAPIではなくURL生成ですが、考え方は同じです。
             */
            calculateApiFetchInterval(baseInterval) {
                // スピード係数と頻度係数を掛け合わせ、総合的な「消費速度」係数を算出
                let combinedFactor = this.state.currentSpeedFactor * this.state.currentQuantityFactor;
                // 消費係数が極端に小さい場合に間隔が無限大になるのを防ぐため、下限値を設定
                if (combinedFactor <= 0.1) combinedFactor = 0.1;

                // 基本間隔を消費係数で割る（消費が速いほど間隔は短くなる）
                let interval = baseInterval / combinedFactor;

                // 計算された間隔が、設定された安全な最小/最大範囲内に収まるように調整
                interval = Math.max(this.config.minApiFetchIntervalSafety, interval); // 最小値より短くならないように
                interval = Math.min(this.config.maxApiFetchIntervalSafety, interval); // 最大値より長くならないように
                return interval; // 計算結果の間隔（ミリ秒）を返す
            },

            /* --- 画像URL生成のスケジュール (scheduleImageUrlGeneration) ---
             * 次回の画像URL生成処理 (generateAndAddImageUrls) を、
             * 指定された遅延時間 (delay) の後に実行するように予約 (setTimeout) するメソッド。
             * 処理完了後、次のスケジュールを自動的に設定します。
             */
            scheduleImageUrlGeneration(delay) {
                // console.log(`${delay}ms 後に次のURL生成をスケジュールします`); // デバッグ用ログ
                // もし既に次の生成処理がスケジュールされていたら、それをキャンセル（重複実行防止）
                if (this.state.imageUrlGenerationTimeoutId) clearTimeout(this.state.imageUrlGenerationTimeoutId);

                // setTimeoutを使って、delayミリ秒後に指定した関数を実行するように予約
                this.state.imageUrlGenerationTimeoutId = setTimeout(() => {
                    // ★ タイマーが実行されたら、まずタイマーIDをnullにリセット
                    // これにより、「現在スケジュールされているか」の判定が正しく行える
                    this.state.imageUrlGenerationTimeoutId = null;

                    // 1. 画像URLを生成・追加する処理を実行
                    this.generateAndAddImageUrls();
                    // 2. 次の生成までの間隔を、現在の設定に基づいて計算
                    const nextInterval = this.calculateApiFetchInterval(this.config.imageUrlGenerationInterval);
                    // 3. 計算された間隔で、再度このスケジュールメソッドを呼び出し、次の生成を予約
                    this.scheduleImageUrlGeneration(nextInterval);
                }, delay); // 指定されたミリ秒数だけ待機
            },

            /* --- 画像URL生成スケジュールの再開/開始 (restartImageUrlGeneration) ---
             * 画像URLの定期的生成処理を開始または再開するメソッド。
             * 設定変更時などに呼び出され、現在の設定に基づいた間隔でスケジュールし直します。
             */
            restartImageUrlGeneration(initialDelay = 500) { // 初回実行までの遅延時間（デフォルト500ms）
                // console.log("画像URL生成スケジュールを再開/開始します"); // デバッグ用ログ
                // 既存のスケジュール（もしあれば）をキャンセル
                if (this.state.imageUrlGenerationTimeoutId) {
                    clearTimeout(this.state.imageUrlGenerationTimeoutId);
                    this.state.imageUrlGenerationTimeoutId = null; // IDをリセット
                }
                 // 新しいスケジュールを開始（指定された初回遅延時間で）
                this.scheduleImageUrlGeneration(initialDelay);
            },

            /* --- スピード更新 (updateSpeed) ---
             * 落下スピード設定が変更されたときに呼び出されるメソッド。
             * 内部状態、表示、localStorageを更新し、必要に応じて落下処理とURL生成を再開します。
             */
            updateSpeed(factor, restartFalling = true) {
                // console.log(`落下スピードを係数 ${factor} に更新します`); // デバッグ用ログ
                // 1. 内部状態（スピード係数）を更新
                this.state.currentSpeedFactor = factor;
                // 2. 設定値をlocalStorageに保存（次回起動時に復元するため）
                // localStorageは文字列しか保存できないため、toString()で変換
                localStorage.setItem('fallingImagesSpeed', factor.toString());

                // 3. スピード表示テキストを更新
                let speedText = "標準"; // デフォルトテキスト
                // 係数の値に応じて表示テキストを決定
                if (factor < 0.6) speedText = "かなり遅い";
                else if (factor < 0.9) speedText = "遅い";
                else if (factor > 1.1 && factor <= 1.5) speedText = "速い";
                else if (factor > 1.5 && factor <= 2.0) speedText = "かなり速い";
                else if (factor > 2.0) speedText = "超高速";
                // 表示用要素が存在すれば、テキストを設定
                if (this.elements.speedValueDisplay) {
                    this.elements.speedValueDisplay.textContent = speedText + ` (x${factor.toFixed(2)})`; // 例: "速い (x1.50)"
                }

                // 4. restartFallingフラグがtrueの場合（通常はこちら）、変更を即時反映させる
                if (restartFalling) {
                    this.stopFalling();  // 現在の落下タイマーを停止
                    this.startFalling(); // 新しいスピードで落下タイマーを開始
                    this.restartImageUrlGeneration(); // URL生成の頻度も再計算してスケジュールし直す
                }
            },

            /* --- 出現頻度更新 (updateQuantity) ---
             * 画像の出現頻度設定が変更されたときに呼び出されるメソッド。
             * updateSpeedとほぼ同様の処理を行います。
             */
            updateQuantity(factor, restartFalling = true) {
                // console.log(`出現頻度を係数 ${factor} に更新します`); // デバッグ用ログ
                this.state.currentQuantityFactor = factor; // 内部状態更新
                localStorage.setItem('fallingImagesQuantity', factor.toString()); // localStorageに保存

                // 表示テキストを更新
                let quantityText = "標準";
                if (factor < 0.6) quantityText = "かなり少ない";
                else if (factor < 0.9) quantityText = "少ない";
                else if (factor > 1.1 && factor <= 1.8) quantityText = "多い";
                else if (factor > 1.8 && factor <= 2.5) quantityText = "かなり多い";
                else if (factor > 2.5) quantityText = "非常に多い";
                 if (this.elements.quantityValueDisplay) { // 要素存在チェック
                    this.elements.quantityValueDisplay.textContent = quantityText + ` (x${factor.toFixed(2)})`;
                 }

                // 変更を即時反映
                if (restartFalling) {
                    this.stopFalling();
                    this.startFalling();
                    this.restartImageUrlGeneration(); // URL生成頻度も更新
                }
            },

            /* --- テーマ更新 (updateTheme) ---
             * テーマ設定が変更されたときに呼び出されるメソッド。
             * body要素のクラスを切り替え、localStorageに保存し、メーターの色を更新します。
             */
            updateTheme(themeName) {
                // console.log(`テーマを ${themeName} に更新します`); // デバッグ用ログ
                // 1. body要素から既存のテーマクラス (theme-***) を削除
                // 正規表現を使って 'theme-' で始まるクラスをすべて置換して削除し、前後の空白をトリム
                document.body.className = document.body.className.replace(/theme-\S+/g, '').trim();
                // 2. 新しいテーマクラスをbody要素に追加
                document.body.classList.add(`theme-${themeName}`);
                // 3. (念のため) 基本フォントクラスが存在するか確認し、なければ追加 (設定パネル表示用)
                 if (!document.body.classList.contains('font-noto-sans-jp')) {
                     document.body.classList.add('font-noto-sans-jp');
                 }
                // 4. 内部状態（現在のテーマ名）を更新
                this.state.currentTheme = themeName;
                // 5. 設定値をlocalStorageに保存
                localStorage.setItem('fallingImagesTheme', themeName);
                // 6. メーターの色を更新
                // テーマ変更後、CSS変数が適用されるのを少し待ってからメーターを更新
                setTimeout(() => this.updateImageUrlStockMeter(), 50); // 50ms後に実行
            },

            /* --- 設定パネル開閉 (toggleSettingsPanel) ---
             * 設定ボタンがクリックされたときに、設定パネルの表示/非表示を切り替えるメソッド。
             */
            toggleSettingsPanel() {
                // 1. パネルの開閉状態フラグ (isPanelOpen) を反転させる (true -> false, false -> true)
                this.state.isPanelOpen = !this.state.isPanelOpen;
                // console.log(`設定パネルを切り替え。 開いている状態: ${this.state.isPanelOpen}`); // デバッグ用ログ

                // 2. 設定パネル要素 (settingsPanel) に 'open' クラスを付け外しする
                // 第2引数に true/false を渡すと、trueならクラスを追加、falseならクラスを削除する
                if (this.elements.settingsPanel) { // 要素存在チェック
                    this.elements.settingsPanel.classList.toggle('open', this.state.isPanelOpen);
                }
                // 3. 設定ボタンのテキストを「閉じる」または「設定」に切り替える
                if (this.elements.settingsButton) { // 要素存在チェック
                    this.elements.settingsButton.textContent = this.state.isPanelOpen ? '閉じる' : '設定';
                }
            }
        }; // FallingImages オブジェクト定義の終わり

        // --- アプリケーションの初期化処理の呼び出し ---
        // HTMLドキュメントの構造が完全に読み込まれ、解析された後に実行されるイベント
        window.addEventListener('DOMContentLoaded', () => {
            try { // 初期化処理全体をtry...catchで囲み、致命的なエラーを捕捉
                // FallingImagesオブジェクトのinitメソッドを呼び出してアプリケーションを開始
                FallingImages.init();
            } catch (error) {
                console.error("初期化中に致命的なエラーが発生しました:", error);
                // ユーザーにエラーが発生したことを通知する（より親切な方法も検討可能）
                alert("アプリケーションの起動中にエラーが発生しました。開発者コンソールを確認してください。");
            }
        });

    </script>
</body>
</html>

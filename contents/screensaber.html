<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>スクリーンセーバー</title>
    <meta name="article-number" content="000007">
    <meta name="description" content="スクリーンセーバーと時計。集中力を上げたい時に。">

    <style>
        /* 基本的なページスタイルのリセットと設定 */
        body, html {
            margin: 0; /* ブラウザデフォルトのマージンを削除 */
            padding: 0; /* ブラウザデフォルトのパディングを削除 */
            width: 100%; /* 幅を画面全体に */
            height: 100%; /* 高さを画面全体に */
            overflow: hidden; /* スクロールバーが出ないようにする */
            font-family: 'Courier New', Courier, monospace; /* 等幅フォントを指定 */
            display: flex; /* Flexboxを使用して中央揃えを実現 */
            flex-direction: column; /* 要素を縦方向に並べる */
            justify-content: center; /* 垂直方向中央揃え */
            align-items: center; /* 水平方向中央揃え */
            position: relative; /* Canvasを背面に配置するための基準点 */
            cursor: pointer; /* マウスカーソルをクリック可能な形状に変更 */
            transition: background-color 0.8s ease; /* 背景色の変化を0.8秒かけて滑らかに行う */
        }

        /* 時計表示用のスタイル */
        #clock {
            font-size: 10vw; /* フォントサイズをビューポート幅の10%に（レスポンシブ対応） */
            font-weight: bold; /* 太字に */
            z-index: 10; /* 他の要素より手前に表示するための重ね順 */
            transition: color 0.8s ease, text-shadow 0.8s ease; /* 文字色と影の変化を滑らかに */
        }

        /* PC表示時の時計フォントサイズ調整 */
        @media (min-width: 768px) { /* 画面幅が768px以上の場合に適用 */
            #clock {
                font-size: 80px; /* 固定フォントサイズに */
            }
        }
        
        /* 背景アニメーション用Canvasのスタイル */
        #screensaverCanvas {
            position: absolute; /* 親要素(body)を基準に絶対位置指定 */
            top: 0;
            left: 0;
            width: 100%; /* 親要素いっぱいに広げる */
            height: 100%;
            z-index: 1; /* 時計(#clock)より背面に表示するための重ね順 */
        }
        /* ================================================================== */
        /* ナビゲーションメニューのスタイル (ここからコピー)                   */
        /* ================================================================== */

        /* メニューを開閉するアイコンボタンのスタイル */
        #menu-toggle-icon {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;

            position: fixed;
            /* 画面に固定表示 */
            top: 15px;
            /* 画面上から15pxの位置 */
            right: 20px;
            /* 画面右から20pxの位置 */
            font-size: 28px;
            /* アイコンの文字サイズ */
            font-weight: bold;
            /* 太字にする */
            color: #333;
            /* アイコンの色 (濃いグレー) */
            background-color: rgba(255, 255, 255, 0.8);
            /* 背景色 (半透明の白) */
            width: 45px;
            /* ボタンの幅 */
            height: 45px;
            /* ボタンの高さ */
            border-radius: 50%;
            /* 円形にする */
            text-align: center;
            /* 文字を中央揃え */
            line-height: 45px;
            /* 文字を垂直方向に中央揃え */
            cursor: pointer;
            /* カーソルを指マークに */
            z-index: 1002;
            /* 他の要素より手前に表示 */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            /* 影をつけて立体感を出す */
            transition: transform 0.2s, background-color 0.2s;
            /* アニメーション効果 */
        }

        /* アイコンにマウスを乗せたときのスタイル */
        #menu-toggle-icon:hover {
            transform: scale(1.1);
            /* 少し大きくする */
            background-color: rgba(255, 255, 255, 1);
            /* 背景を不透明の白に */
        }

        /* フローティングメニュー本体のスタイル */
        #floating-menu {
            position: fixed;
            /* 画面に固定表示 */
            top: 70px;
            /* アイコンの下に配置 */
            right: 20px;
            /* アイコンと同じ右からの位置 */
            background-color: rgba(255, 255, 255, 0.98);
            /* 背景色 (ほぼ不透明の白) */
            padding: 15px 20px;
            /* 内側の余白 */
            border-radius: 8px;
            /* 角を丸くする */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            /* 影をつける */
            display: flex;
            /* 内部のリンクをFlexboxで配置 */
            flex-direction: column;
            /* リンクを縦に並べる */
            gap: 10px;
            /* リンク間の隙間 */
            z-index: 1001;

            /* アニメーションのための初期設定 */
            transform-origin: top right;
            /* 右上を基点にアニメーション */
            transform: scale(0.95);
            opacity: 0;
            visibility: hidden;
            /* 表示されていないときは操作不可に */
            transition: transform 0.2s ease-out, opacity 0.2s ease-out, visibility 0.2s;
        }

        /* メニューが表示されるときのスタイル（showクラスが付与されたとき） */
        #floating-menu.show {
            transform: scale(1);
            opacity: 1;
            visibility: visible;
        }

        /* メニュー内のリンクのスタイル */
        #floating-menu a {
            color: #007bff;
            /* リンクの文字色 */
            text-decoration: none;
            font-size: 1.1rem;
            font-weight: bold;
            padding: 10px;
            transition: background-color 0.2s;
            border-radius: 5px;
        }

        #floating-menu a:hover {
            background-color: #f0f0f0;
            /* ホバー時の背景色 */
        }

        /* ================================================================== */
        /* ナビゲーションメニューのスタイル (ここまでコピー)                   */
        /* ================================================================== */

    </style>
</head>
<body>
    <!-- ================================================================== -->
    <!-- ナビゲーションメニュー ここから (ここからコピー)                  -->
    <!-- ================================================================== -->
    
    <!-- 画面右上に表示されるメニュー開閉ボタン -->
    <div id="menu-toggle-icon">≡</div>
    
    <!-- クリック時に表示されるフローティングメニュー -->
    <div id="floating-menu">
        <!-- 各ページへのリンク。パスは適宜調整してください -->
        <a href="../index.html">トップページへ</a>
        <a href="../contents.html">コンテンツ一覧へ</a>
    </div>
    
    <!-- ================================================================== -->
    <!-- ナビゲーションメニュー ここまで (ここまでコピー)                  -->
    <!-- ================================================================== -->

    <!-- 背景アニメーションを描画するCanvas要素 -->
    <canvas id="screensaverCanvas"></canvas>
    <!-- 現在時刻を表示するdiv要素 -->
    <div id="clock"></div>

    <script>
            /* ================================================================== */
            /* ナビゲーションメニューの制御スクリプト (ここからコピー)             */
            /* ================================================================== */
            document.addEventListener('DOMContentLoaded', () => {
                // HTML要素を取得
                const menuToggleIcon = document.getElementById('menu-toggle-icon');
                const floatingMenu = document.getElementById('floating-menu');

                // アイコンとメニュー要素が存在する場合のみイベントリスナーを設定
                if (menuToggleIcon && floatingMenu) {

                    // メニューアイコンをクリックしたらメニューの表示/非表示を切り替える
                    menuToggleIcon.addEventListener('click', (event) => {
                        // イベントの伝播を停止し、下のdocumentのクリックイベントがすぐに発火するのを防ぐ
                        event.stopPropagation();
                        floatingMenu.classList.toggle('show');
                    });

                    // メニューの外側をクリックしたときにメニューを閉じる
                    document.addEventListener('click', (event) => {
                        // メニューが表示されている状態か確認
                        if (floatingMenu.classList.contains('show')) {
                            // クリックされたのがメニューアイコンでも、メニュー自身でもない場合
                            if (!menuToggleIcon.contains(event.target) && !floatingMenu.contains(event.target)) {
                                floatingMenu.classList.remove('show');
                            }
                        }
                    });
                }
            });
            /* ================================================================== */
            /* ナビゲーションメニューの制御スクリプト (ここまでコピー)             */
            /* ================================================================== */

        /* ===== グローバルスコープの変数と定数 ===== */

        // HTML要素への参照を取得
        const clockElement = document.getElementById('clock'); // 時計表示用div
        const canvas = document.getElementById('screensaverCanvas'); // アニメーション用canvas
        const ctx = canvas.getContext('2d'); // canvasに2Dグラフィックを描画するためのコンテキスト
        const bodyElement = document.body; // body要素（背景色変更のため）

        // 現在選択されているテーマのインデックス（0から始まる）
        // 初期テーマは配列の2番目の要素 (インデックス1)
        let currentThemeIndex = 1; 

        // スクリーンセーバーのテーマ定義配列
        // 各テーマはオブジェクトで、背景色、時計の色、パーティクルの色などが含まれる
        const themes = [
            { // インデックス 0: Cyber Green+
                name: "Cyber Green+",
                bodyBgColor: "#000500", // body要素の背景色
                clockColor: "#00FF00",  // 時計の文字色
                clockShadow: "0 0 7px #00FF00, 0 0 15px #00FF00, 0 0 25px #00CF00, 0 0 35px #009F00", // 時計の文字の影（ネオン効果）
                particleColors: ['#00FF00', '#00DD00', '#00AA00', '#33FF33', '#66FF66', '#008800', '#006600'], // パーティクルに使用する色の候補
                canvasBgColor: "#000500" // Canvas自体の背景色
            },
            { // インデックス 1: Cosmic Blue+ (初期テーマ)
                name: "Cosmic Blue+",
                bodyBgColor: "#01001A",
                clockColor: "#A0CAFF",
                clockShadow: "0 0 8px #82AAFF, 0 0 18px #536DFE, 0 0 28px #3D5AFE, 0 0 40px #7E57C2",
                particleColors: ['#82AAFF', '#536DFE', '#3D5AFE', '#7E57C2', '#A0CAFF', '#C5CAE9', '#E1F5FE', '#FFFFFF'],
                canvasBgColor: "#01001A"
            },
            { // インデックス 2: Sunset Orange+
                name: "Sunset Orange+",
                bodyBgColor: "#3B1200",
                clockColor: "#FFFACD",
                clockShadow: "0 0 10px #FFD700, 0 0 20px #FFA500, 0 0 35px #FF7F50, 0 0 50px #FF4500",
                particleColors: ['#FFD700', '#FFA500', '#FF8C00', '#FF7F50', '#FF6347', '#FFEC8B', '#FFDEAD'],
                canvasBgColor: "#3B1200"
            },
            { // インデックス 3: Forest Mist+
                name: "Forest Mist+",
                bodyBgColor: "#001A0F",
                clockColor: "#C1D8C3",
                clockShadow: "0 0 10px #A2B5A4, 0 0 20px #6A8C69, 0 0 30px #4B6C4A",
                particleColors: ['#A2B5A4', '#86A888', '#6A8C69', '#4B6C4A', '#DAF7A6', '#B4CBB0'],
                canvasBgColor: "#001A0F"
            },
            { // インデックス 4: Aurora Borealis
                name: "Aurora Borealis",
                bodyBgColor: "#010115",
                clockColor: "#98FB98",
                clockShadow: "0 0 10px #40E0D0, 0 0 20px #98FB98, 0 0 30px #BA55D3, 0 0 40px #87CEEB",
                particleColors: ['#40E0D0', '#98FB98', '#BA55D3', '#87CEEB', '#FF69B4', '#7FFF00'],
                canvasBgColor: "#010115"
            },
            { // インデックス 5: Retro Arcade
                name: "Retro Arcade",
                bodyBgColor: "#000000",
                clockColor: "#FFD300",
                clockShadow: "0 0 5px #FF8C00, 0 0 10px #FF4500, 0 0 15px #FF0000",
                particleColors: ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#FFA500'],
                canvasBgColor: "#000000"
            },
            { // インデックス 6: Deep Sea
                name: "Deep Sea",
                bodyBgColor: "#000020",
                clockColor: "#B0E0E6",
                clockShadow: "0 0 12px #ADD8E6, 0 0 22px #87CEFA, 0 0 32px #00BFFF, 0 0 45px #1E90FF",
                particleColors: ['#AFEEEE', '#7FFFD4', '#B0E0E6', '#E0FFFF', '#F0FFFF', '#FFFFFF', '#6495ED'],
                canvasBgColor: "#000020"
            },
            { // インデックス 7: Night Sakura
                name: "Night Sakura",
                bodyBgColor: "#100018",
                clockColor: "#FFC0CB",
                clockShadow: "0 0 8px #FFB6C1, 0 0 16px #FF69B4, 0 0 24px #DB7093, 0 0 32px #C71585",
                particleColors: ['#FFC0CB', '#FFB6C1', '#FFDAE9', '#FFE4E1', '#FFF0F5', '#FFFFFF', '#F8BBD0'],
                canvasBgColor: "#100018"
            },
            { // インデックス 8: Volcanic Ember
                name: "Volcanic Ember",
                bodyBgColor: "#180500",
                clockColor: "#FF7F00",
                clockShadow: "0 0 10px #FF4500, 0 0 20px #FF6347, 0 0 30px #DC143C, 0 0 40px #8B0000",
                particleColors: ['#FF4500', '#FF6347', '#FF8C00', '#FFA500', '#FFD700', '#FF0000', '#CD5C5C', '#B22222'],
                canvasBgColor: "#180500"
            }
        ];

        // アニメーションのパーティクル（オブジェクト）を格納する配列
        let particlesArray = [];
        // requestAnimationFrameのIDを保持する変数。アニメーションの停止に使う。
        let animationFrameId;

        /* ===== 関数定義 ===== */

        /**
         * @function updateClock
         * @description 現在時刻を取得し、時計表示を更新する。1秒ごとに呼び出される。
         */
        function updateClock() {
            const now = new Date(); // 現在の日時情報を取得
            // 時、分、秒を2桁の文字列で取得 (例: 7時 -> "07")
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            // 時計エレメントのテキスト内容を更新
            clockElement.textContent = `${hours}:${minutes}:${seconds}`;
        }

        /**
         * @class Particle
         * @description 個々のパーティクル（画面上を動く円）の設計図（クラス）。
         *              位置、速度、サイズ、色などの情報を持つ。
         */
        class Particle {
            /**
             * @constructor
             * @param {number} x - パーティクルの初期X座標
             * @param {number} y - パーティクルの初期Y座標
             * @param {number} directionX - X方向の初期速度
             * @param {number} directionY - Y方向の初期速度
             * @param {number} size - パーティクルの半径
             * @param {object} initialTheme - パーティクル生成時のテーマ情報（主に色取得のため）
             */
            constructor(x, y, directionX, directionY, size, initialTheme) {
                this.x = x; // X座標
                this.y = y; // Y座標
                this.directionX = directionX; // X方向の速度
                this.directionY = directionY; // Y方向の速度
                this.size = size; // 半径（大きさ）
                // パーティクルの色を、現在のテーマのparticleColors配列からランダムに選択
                this.color = initialTheme.particleColors[Math.floor(Math.random() * initialTheme.particleColors.length)];
                this.mass = this.size; // 質量。衝突計算で使うことがある（今回は単純な反射なので直接の影響は少ない）
            }

            /**
             * @method draw
             * @description Canvasにこのパーティクル（円）を描画する。
             */
            draw() {
                ctx.beginPath(); // 新しい描画パスを開始
                // arc(中心X, 中心Y, 半径, 開始角度, 終了角度, 反時計回りか否か)
                // Math.PI * 2 は360度（円全体）を表す
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color; // 塗りつぶしの色を設定
                ctx.fill(); // 現在のパスを塗りつぶす
            }

            /**
             * @method update
             * @description パーティクルの位置を速度に基づいて更新し、画面の端に衝突したら反射させる。
             */
            update() {
                // X方向の壁衝突判定と反射
                if (this.x + this.size > canvas.width || this.x - this.size < 0) {
                    this.directionX = -this.directionX; // X方向の速度を反転
                    // 壁にハマるのを防ぐため、位置を少し補正
                    if (this.x + this.size > canvas.width) this.x = canvas.width - this.size;
                    if (this.x - this.size < 0) this.x = this.size;
                }
                // Y方向の壁衝突判定と反射
                if (this.y + this.size > canvas.height || this.y - this.size < 0) {
                    this.directionY = -this.directionY; // Y方向の速度を反転
                    // 壁にハマるのを防ぐため、位置を少し補正
                    if (this.y + this.size > canvas.height) this.y = canvas.height - this.size;
                    if (this.y - this.size < 0) this.y = this.size;
                }

                // 速度に基づいて位置を更新
                this.x += this.directionX;
                this.y += this.directionY;
            }
            
            /**
             * @method render
             * @description パーティクルを描画する (drawメソッドを呼び出すだけのラッパー)。
             *              アニメーションループ内で、更新処理と描画処理を分けるために用意。
             */
            render() {
                this.draw();
            }

            /**
             * @method updateColor
             * @description テーマが変更された際に、パーティクルの色を新しいテーマに合わせて更新する。
             * @param {object} theme - 新しいテーマオブジェクト
             */
            updateColor(theme) {
                this.color = theme.particleColors[Math.floor(Math.random() * theme.particleColors.length)];
            }
        }

        /**
         * @function initParticles
         * @description 画面上に表示するパーティクル群を初期化（生成）する。
         *              ウィンドウリサイズ時や初回起動時に呼び出される。
         */
        function initParticles() {
            particlesArray = []; // 既存のパーティクルを一旦空にする
            const currentTheme = themes[currentThemeIndex]; // 現在のテーマ情報を取得（主に色のため）

            // 画面サイズに応じてパーティクルの数を決定
            // canvasの面積 / 9000 を基準にする (この値で密度を調整)
            const baseParticleCount = (canvas.width * canvas.height) / 9000;
            // 最低でも200個は表示するようにする
            const numberOfParticles = Math.max(200, Math.floor(baseParticleCount));

            // 指定された数だけパーティクルを生成
            for (let i = 0; i < numberOfParticles; i++) {
                let size; // パーティクルのサイズ（半径）
                // サイズにバリエーションを持たせる (15%の確率で大きなパーティクル)
                if (Math.random() < 0.15) { // Math.random()は0以上1未満の乱数を返す
                    size = Math.random() * 10 + 12; // 大きなサイズ: 12px から 22px (12 + 0～10)
                } else {
                    size = Math.random() * 8 + 2;  // 通常サイズ: 2px から 10px (2 + 0～8)
                }

                let x, y, validPosition; // 初期位置(x,y)と、その位置が有効かのフラグ
                let attempts = 0; // 初期位置決定の試行回数

                // 他のパーティクルと重ならない初期位置を探す (最大100回試行)
                // do...whileループ: 最低1回は実行し、条件(validPositionがfalseかつattemptsが100未満)を満たす間繰り返す
                do {
                    validPosition = true; // 一旦、有効な位置と仮定
                    // Canvas内のランダムな位置を生成 (画面端にハマらないようにsizeを考慮)
                    x = Math.random() * (canvas.width - size * 2) + size;
                    y = Math.random() * (canvas.height - size * 2) + size;

                    // 既に配置済みの他のパーティクルと重なっていないかチェック
                    for (let j = 0; j < particlesArray.length; j++) {
                        const other = particlesArray[j];
                        const dx = x - other.x; // X座標の差
                        const dy = y - other.y; // Y座標の差
                        // 2点間の距離を計算 (三平方の定理: a^2 + b^2 = c^2)
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        // 距離が「自分の半径 + 相手の半径 + 少しのマージン」より小さい場合は衝突している
                        if (distance < size + other.size + 2) {
                            validPosition = false; // 無効な位置
                            break; // 内側のループを抜ける
                        }
                    }
                    attempts++; // 試行回数を増やす
                } while (!validPosition && attempts < 100);

                // もし100回試行しても有効な位置が見つからなければ、ランダムな位置に配置 (非常に稀)
                if (!validPosition) {
                    x = Math.random() * (canvas.width - size * 2) + size;
                    y = Math.random() * (canvas.height - size * 2) + size;
                }

                // パーティクルの初期速度をランダムに決定
                const angle = Math.random() * Math.PI * 2; // 0から2π(360度)のランダムな角度
                let speedMagnitude; // 速さの大きさ
                // 大きなパーティクルは少し遅く、小さなパーティクルは少し速くする（お好みで調整）
                if (size >= 12) { // 半径が12以上の場合
                    speedMagnitude = Math.random() * 0.3 + 0.2; // 0.2 ～ 0.5 の範囲の速さ
                } else {
                    speedMagnitude = Math.random() * 0.5 + 0.25;  // 0.25 ～ 0.75 の範囲の速さ
                }
                
                // 角度と速さからX方向とY方向の速度成分を計算
                const directionX = Math.cos(angle) * speedMagnitude;
                const directionY = Math.sin(angle) * speedMagnitude;
                
                // 新しいParticleオブジェクトを生成し、particlesArrayに追加
                particlesArray.push(new Particle(x, y, directionX, directionY, size, currentTheme));
            }
        }

        /**
         * @function animateParticles
         * @description メインのアニメーションループ。毎フレーム呼び出され、画面を更新する。
         *              requestAnimationFrameによって、ブラウザの描画タイミングに合わせて効率的に実行される。
         */
        function animateParticles() {
            const currentTheme = themes[currentThemeIndex]; // 現在のテーマを取得

            // 1. Canvas全体を現在のテーマの背景色で塗りつぶす (前のフレームの描画を消去)
            ctx.fillStyle = currentTheme.canvasBgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height); // (左上X, 左上Y, 幅, 高さ)

            // 2. 各パーティクルの位置を更新し、壁との衝突処理を行う
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update();
            }

            // 3. パーティクル同士の衝突判定と応答処理
            //    効率のため、各ペアは1回だけチェックする (i と j=i+1 から開始)
            for (let i = 0; i < particlesArray.length; i++) {
                for (let j = i + 1; j < particlesArray.length; j++) {
                    const p1 = particlesArray[i]; // 1つ目のパーティクル
                    const p2 = particlesArray[j]; // 2つ目のパーティクル

                    // p1とp2の中心間の距離を計算
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    // 衝突すべき最小距離 (p1の半径 + p2の半径)
                    const minDistance = p1.size + p2.size;

                    // 実際の距離が最小距離より小さい場合、衝突していると判定
                    if (distance < minDistance) {
                        // a. 重なり解消処理: パーティクルがめり込んでいる分を押し出す
                        const overlap = minDistance - distance; // 重なっている距離
                        // 衝突の法線ベクトル (p1からp2への方向、正規化されている)
                        const nx = dx / distance; // X成分
                        const ny = dy / distance; // Y成分
                        // 重なりの半分ずつ、互いを反対方向に押し出す
                        p1.x -= nx * overlap / 2;
                        p1.y -= ny * overlap / 2;
                        p2.x += nx * overlap / 2;
                        p2.y += ny * overlap / 2;
                        
                        // b. 衝突応答 (速度の交換): 最も単純な反射モデル
                        //    よりリアルな物理的反射は複雑な計算が必要だが、ここでは速度を入れ替えるだけ
                        const tempDirX_p1 = p1.directionX;
                        const tempDirY_p1 = p1.directionY;
                        p1.directionX = p2.directionX;
                        p1.directionY = p2.directionY;
                        p2.directionX = tempDirX_p1;
                        p2.directionY = tempDirY_p1;
                    }
                }
            }
            
            // 4. 全てのパーティクルをCanvasに描画する
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].render();
            }

            // 次のフレームで再びanimateParticlesを呼び出すようブラウザに依頼
            animationFrameId = requestAnimationFrame(animateParticles);
        }

        /**
         * @function applyTheme
         * @description 指定されたテーマを画面全体に適用する。
         *              bodyの背景色、時計のスタイル、パーティクルの色などを変更。
         * @param {object} theme - 適用するテーマオブジェクト
         */
        function applyTheme(theme) {
            // body要素の背景色をテーマに合わせて変更
            bodyElement.style.backgroundColor = theme.bodyBgColor;
            // 時計の文字色と影をテーマに合わせて変更
            clockElement.style.color = theme.clockColor;
            clockElement.style.textShadow = theme.clockShadow;
            
            // Canvasの背景色を即時反映 (アニメーションループでも設定するが、切り替え感を出すため)
            ctx.fillStyle = theme.canvasBgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 既存のパーティクルがあれば、その色を新しいテーマに合わせて更新
            if (particlesArray && particlesArray.length > 0) {
                particlesArray.forEach(particle => { // 配列の各要素に対して処理を実行
                    particle.updateColor(theme);
                });
            } else {
                // パーティクルが存在しない場合（初回起動時など）は、新しく生成する
                initParticles();
            }

            // アニメーションがまだ開始されていなければ開始する
            if (!animationFrameId) {
                animateParticles();
            }
        }

        /**
         * @function changeTheme
         * @description 画面クリック（タップ）時に呼び出され、次のテーマに切り替える。
         */
        function changeTheme() {
            // 現在のテーマインデックスを1増やし、テーマ配列の要素数で割った余りを新しいインデックスとする
            // これにより、最後のテーマの次は最初のテーマに戻る（ループする）
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            const nextTheme = themes[currentThemeIndex]; // 次のテーマオブジェクトを取得
            
            // コンソールにデバッグ情報を出力（開発者ツールで確認できる）
            console.log("Changing theme to:", nextTheme.name);
            
            // 新しいテーマを適用
            applyTheme(nextTheme);
        }

        /**
         * @function resizeCanvas
         * @description ウィンドウサイズが変更されたときに呼び出され、Canvasのサイズを調整し、
         *              パーティクルを再初期化する。
         */
        function resizeCanvas() {
            // Canvasの幅と高さを現在のウィンドウの内部寸法に合わせる
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // もしアニメーションが実行中なら一旦停止する
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId); // アニメーションフレームのキャンセル
                animationFrameId = null; // IDをクリア
            }

            // パーティクルを再初期化 (新しい画面サイズに合わせて再生成)
            initParticles(); 

            // アニメーションが停止しており、かつパーティクルが存在する場合、アニメーションを再開
            if (!animationFrameId && particlesArray.length > 0) {
                 animateParticles();
            }
        }
        // ウィンドウリサイズイベントが発生したらresizeCanvas関数を実行するよう登録
        window.addEventListener('resize', resizeCanvas);

        /* ===== 初期化処理 ===== */

        // 1. 時計の初期表示と、1秒ごとの更新設定
        updateClock(); // ページ読み込み時に一度時計を表示
        setInterval(updateClock, 1000); // 1000ミリ秒 (1秒) ごとにupdateClockを実行
        
        // 2. Canvasのサイズ設定、初期パーティクルの生成、アニメーションの開始
        resizeCanvas(); // これによりinitParticlesとanimateParticlesが適切に呼ばれる
        
        // 3. 初期テーマの適用 (スタイルやパーティクルの色など)
        //    resizeCanvas内でパーティクルは生成されるが、時計の色などのスタイル適用はここで行う
        applyTheme(themes[currentThemeIndex]);
        
        // 4. 画面クリック（タップ）でテーマを変更するイベントリスナーを登録
        document.addEventListener('click', changeTheme);

    </script>
</body>
</html>